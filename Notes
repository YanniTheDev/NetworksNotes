OSI (Open Systems Interconnection) Model - It is a conceptual model that represents how a network communicates. Because network communication is complex, the model is comprised of seven layers, each with a different task.
Layer 1: Physical Layer - Is the physical and electrical representation of the system. It consists of lots of different types of network components such as power plugs, connectors, receievers, cable types, etc. The physical layer sends bits (0s and 1s) from one device to another. It also defines how the 0s and 1s are encoded in a signal. Overall, the physical layer is responsible for the communication of unstructured raw data streams over a physical medium.
Protocols: Ethernet, Bluetooth

Layer 2: Data Link Layer - This layer is responsible for the node-to-node delivery of data. Each computer or device in a network is called a "node". Its major role is to ensure error-free transmission of information. This layer introduces the hardware parts of the network too, such as the MAC address. This layer is also responsible for encoding, decoding, and organizing the outgoing and incoming data.
Protocols: MAC

Layer 3: Network Layer - The main function of this layer is to transfer packets of data from the source to the destination. It involves both the source host and the destination host. The network layer provides the services, packetizing, routing, and forwarding. Packetizing involves encapuslating data into packets suitable for transmission. Routing determines the optimal path in the network the packet should take for the journey to be efficient. Finally, forwarding is the process of directing these packets to their next destination in the network.
Protocols: IP, ARP (converts MAC address to IP address)

Layer 4: Transport Layer - It is an end-to-end layer used to deliver messages to a host. The Transport layer works a bit differently depending on whether the user is receiving or sending. If the user is sending, the transport layer receives message from the Application layer, and performs segmentation, which is basically dividing the message up into segments. Then the Transport layer adds the source and destination's port numbers into the header of the segment, and then passes it to the Network layer. If the user is receiving, the transport layer reassembles the message, reads the header and port number, and forwards the message to that port on the Application layer.
Protocols: UDP, TCP

Layer 5: Session Layer - This layer allows users on different machines to establish active communications with each other. The main responsibility of the session layer is to establish, maintain, synchronize, and terminate sessions between end-to-end user applications.
Protocols: NetBIOS

Layer 6: Presentation Layer - This layer serves as a data translator for the network. The data which this layer receives from the Application layer is extracted and then manipulated to the required format to transmit over the network. The main responsibility of this layer is to define the data format and encryption. It also maintains the proper syntax of the data that is being transferred.
Protocols: TLS, SSL, FTP

Layer 7: Application Layer - The application layer provides the functionality to send and receive data from users. It acts like an interface between the user and the application. The application provides services such as file transmission, mail service, and other services provided by the application layer.
Protocols: HTTP, FTP, DNS


HyperText Transfer Protocol (HTTP) - Application Layer (7)
Created by Tim Berners-Lee in 1989.
Transfer HyperText, such as HTML, from a server to the client's computer.
It functions as a simple conversation between the client and the server. Uses a request/reponse pattern for solving the problem of reliable communication between the client and the server. 
Requests and responses can have other data or resources sent along with it, such as an user ID.
Nine types of requests:
GET request - returns what you asked for. Such as a piece of an HTML element or an image file.
HEAD request - returns information about what you will get if you did a GET request. For example, a GET request on a file download will download the file, but a HEAD request will be able to tell the client how big the file is.
POST request - allows clients to send information in the other direction. Clients can replace a resource or data on the server with something they supply with the request. These use something that is called a Uniform Resource Identifier or URI. URI is a unique code or numbe for a resource.
PUT request - similar to POST request. However, if the resource already exists with the same URI, it is modified with the new one.
DELETE request - deletes a resource.
CONNECT request - starts a two-way communications with the requested resource. It can be used to open a tunnel. For example, the CONNECT method can be used to access websites that use TLS. The client asks an HTTP Proxy server to tunnel the TCP connection to the desired connection. The proxy server then proceeds to make the connection on behalf of the client. Once the connection is established, the proxy server continues to relay the TCP stream to and from the client.
PATCH request - allows the client to do a partial modification of a resource. 
The first line of a response is the status line and has a numeric status code such as 404 and text-based reason phrase such as "Not Found". The most common is 200 and this means successful or "OK". The status codes are primarily divided into five groups for better explanation of requests, and responses between client and server are named by purpose and a number: Informational 1XX, Successful 2XX, Redirection 3XX, Client Error 4XX, and Server Error 5XX. 

Internet Chat Relay (IRC) - Application Layer (7)
It is a system that lets you transfer messages in the form of text. It is essentially a chat protocol. It uses a client-server model. Clients are chat programs installed on a user's computer that connects to a central server. The clients communicate the message to the central server which in turns relays that to other clients. This protocol was originally designed for group communication in discussion forums, called channels. IRC also supports private messages, and file and data transfer. IRC allows users to use commands to interact with the server, client, or other users. For example, /DIE will tell the server to shutdown, etc. IRC is similar to Discord. Groups exist in the forms of channels. A server hosts many channels, and you can choose which one to join. Each channel usually form around on topic. Convention dictates that channel names start with one or two # symbols.

Transimission Control Protocol (TCP) - Transport Layer 4
Breaks up large messages into something called packets. A packet is a segment of data that, when combined with other packets, make up one whole message. Things like websites are broken into packets, then sent over the Internet.
The receiving computer reassembles the packets back into the whole message. Breaking it up into packets makes it so that the data is easier to transfer through the Internet. Some packets can get to the destination first, while if the message was being sent as a whole, it will have to wait a long time for the message to come.
However, sometimes the packets can get either lost, corrupted, or delayed, when travelling through the Internet. If this was not fixed, the image either would not load, have missing bits, corrupted, all everything. Packets experience these troubles because they go through various nodes. These nodes are basically different routers or computers. One route might experience more interference (causing packet loss), another might be faster or slower than another (causing packets to become out of order). Corruption can happen at any time through electric interference. TCP is a protocol that solves these issues.
Computers first do a TCP handshake, which is two computers telling each other that they will be using TCP for data transfer, and making sure the connection is continued throughout the data transfer. Then, they do something called ordering. TCP puts something called a sequence number on each of the packets, which signifies its order number. With the sequence number, the receiving computer can re-order the packets into the correct order. If the packets are out of order, TCP will wait until all of the packets arrive, then puts them back in order. Another concept is called checksums. Checksums is a little piece of data in the data that is being transferred. If the data gets corrupted, then the checksum will get corrupted with it. The receiving computer will then check if the checksum they have is matched with the initial checksum. If the checksum is different, then the data has been corrupted and the the receiving computer will request for the data again. 
TCP uses something called acknowledgement (ACK) and negative acknowledgement (NACK) messages to re-send data. ACKs are sent to the sending computer from the receiving computer to tell the sending computer the data has arrived and it is usable. NACKs are sent when the data arrives, but is damaged and cannot be used, so the sending computer has to send the packet again. ACKs and NACKs are useful because they allow communication in the opposite direction. Finally, the sending computer will resend a packet if it has not receiving an ACK or NACK after some time for that specific packet. This is called a timeout. Sometimes, ACKs can actually get lost too,, and the timeout gets executed, but the receiving computer will ignore the duplicate.

User Datagram Protocol (UDP) - Transport Layer 4
This is similar to TCP, however this protocol does not guarantee delivery. UDP does not do anything for duplicate packets, lost packets, or out of order packets. All it does is it gets the bulk of the data to one place. Checksums are still used to make sure the data is not corrupted. The packets of data still have formal packet structure, as it includes destination, origin, and packet size. UDP is usually used for "unimportant" data transfer, such as music, video, and VOIP. For example, sometimes video calls on Skype can suddenly become very poor quality, and that is because UDP has lost some packets in the transfer process. However, the bulk of the data has been transferred successfully, so the user can still see the overall picture and the conversation can function fine.

The Internet is made of layers. At each layer, data is made up of the previous layer's whole unit of data, and then headers are added and passed down. At the Link layer, a footer is also added. Footers and headers are meta-data (fancy word for data that describes other data). Headers come before the data, and the footer come afterwards.

For a UDP packet layer, on the application layer, there is only the data. Once it is on the transport layer, there is the UDP header, and UDP data. Then, on the Network layer there will be a packet header, and the packet data composed of the UDP data and the Application layer data. Finally, the Link layer will have a frame header, frame data, and frame footer. A message sent in HTTP will be received on the Transport layer, wrapped in a TCP/UDP header, then wrapped in an IPv6/IPv4 header, then an Ethernet header and footer, and then sent over the Internet. The computer receiving the data will do all of this in reverse. TCP and UDP packets have a number saying how big they are. This number means that the packet can be as big as you like.

The Ethernet protocol stack uses four layers of the OSI model, and also uses the basis of the TCP/IP stack. The four layers are:
 - Physical Layer:
    > This is the same as the Physical layer on the OSI model. Raw data, electric signals, bits, etc. along a wire. All the elements required to serially transmit bits over a communication medium like a           wire. PMA (Physical Medium Attachment) protocol is responsible for signal transmitting and receiving.
 - Data Link Layer:
    > Links together Ethernet devices. At this point, all they can do is move an Ethernet frame one device to another. PCS (Physical Coding Sublayer) protocol is responsible for coding data ready for              transmission, or decoding data received. Either receives a frame from the next layer or sends one to it.
